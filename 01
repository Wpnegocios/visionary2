import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score
from torch.utils.data import DataLoader, TensorDataset
import logging
import requests
from fastapi import FastAPI, HTTPException, Depends
from fastapi.responses import HTMLResponse
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel
import jwt
from datetime import datetime, timedelta
import plotly.graph_objects as go
import plotly.io as pio
import uvicorn

# Configuração de logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Configurações
CONFIG = {
    "model": {"input_size": 10, "hidden_size": 32, "output_size": 3, "lstm_layers": 1, "dropout_prob": 0.2},
    "training": {"epochs": 20, "batch_size": 32, "learning_rate": 0.001, "patience": 5},
    "data": {
        "ativos": ["USD/BRL Futuro", "S&P 500 Futuro"],
        "lookback_period": 20,
        "sequence_length": 10,
        "api": {"provider": "alpha_vantage", "api_key": "YOUR_API_KEY", "use_fallback": True}
    },
    "auth": {"secret_key": "simple-secret-key", "token_expire_minutes": 30}
}

# Autenticação
SECRET_KEY = CONFIG["auth"]["secret_key"]
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = CONFIG["auth"]["token_expire_minutes"]
USERS_DB = {"user": {"username": "user", "password": "password123"}}
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/token")

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username not in USERS_DB:
            raise HTTPException(status_code=401, detail="Usuário inválido")
        return username
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Token inválido")

# Indicadores Técnicos
def calcular_rsi(dados: pd.DataFrame, periodo: int = 14) -> pd.DataFrame:
    delta = dados["close"].diff()
    ganho = delta.where(delta > 0, 0).rolling(window=periodo).mean()
    perda = (-delta.where(delta < 0, 0)).rolling(window=periodo).mean()
    rs = ganho / perda
    dados["RSI"] = (100 - (100 / (1 + rs))).fillna(0)
    return dados

def calcular_medias_moveis(dados: pd.DataFrame) -> pd.DataFrame:
    dados["EMA_9"] = dados["close"].ewm(span=9, adjust=False).mean()
    return dados

def calcular_stochastic_oscillator(dados: pd.DataFrame, periodo: int = 14) -> pd.DataFrame:
    low_min = dados["low"].rolling(window=periodo).min()
    high_max = dados["high"].rolling(window=periodo).max()
    dados["%K"] = 100 * (dados["close"] - low_min) / (high_max - low_min)
    dados["%D"] = dados["%K"].rolling(window=3).mean().fillna(0)
    dados["%K"] = dados["%K"].fillna(0)
    return dados

# Gráficos
def gerar_grafico_precos(dados: pd.DataFrame, ativo: str) -> str:
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=dados.index, y=dados["close"], mode="lines", name="Preço"))
    fig.add_trace(go.Scatter(x=dados.index, y=dados["EMA_9"], mode="lines", name="EMA 9", line=dict(dash="dash")))
    fig.update_layout(title=f"Preços para {ativo}", xaxis_title="Data", yaxis_title="Preço", height=400)
    return pio.to_html(fig, full_html=False)

# Funções de API
def get_dados_ativo(ativo: str, api_config: dict, use_fallback: bool = True) -> pd.DataFrame:
    try:
        logger.info(f"Consultando Alpha Vantage para {ativo}")
        url = f"https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={ativo}&apikey={api_config['api_key']}&outputsize=full"
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        if "Time Series (Daily)" not in data:
            raise ValueError("Formato de resposta inválido")
        df = pd.DataFrame.from_dict(data["Time Series (Daily)"], orient="index")
        df = df.rename(columns={"1. open": "open", "2. high": "high", "3. low": "low", "4. close": "close", "5. volume": "volume"})
        df = df[["high", "low", "close", "volume"]].astype(float)
        df.index = pd.to_datetime(df.index)
        return df
    except Exception as e:
        logger.error(f"Erro ao consultar API: {e}")
        if use_fallback:
            logger.warning(f"Usando dados fictícios para {ativo}")
            data = {
                "high": np.random.rand(500) * 100 + 50,
                "low": np.random.rand(500) * 50 + 20,
                "close": np.random.rand(500) * 80 + 30,
                "volume": np.random.rand(500) * 1000
            }
            return pd.DataFrame(data, index=pd.date_range(start="2023-01-01", periods=500, freq="D"))
        raise

# Pré-processamento
def processar_dados(dados: pd.DataFrame, lookback_period: int) -> tuple[torch.Tensor, object]:
    dados = calcular_rsi(dados)
    dados = calcular_medias_moveis(dados)
    dados = calcular_stochastic_oscillator(dados)
    dados["returns"] = dados["close"].pct_change().fillna(0)
    features = []
    for i in range(lookback_period, len(dados)):
        current_close = dados["close"].iloc[i]
        feature_vector = [
            dados["RSI"].iloc[i],
            dados["EMA_9"].iloc[i] / current_close,
            dados["%K"].iloc[i],
            dados["%D"].iloc[i],
            dados["returns"].iloc[i],
            (dados["close"].iloc[i] - dados["close"].iloc[i-1]) / dados["close"].iloc[i-1] if i > 0 else 0,
            dados["volume"].iloc[i] / dados["volume"].iloc[i-lookback_period:i].mean() if i >= lookback_period else 0,
            (dados["high"].iloc[i] - dados["low"].iloc[i]) / current_close,
            dados["close"].iloc[i] / dados["close"].iloc[i-lookback_period:i].mean() if i >= lookback_period else 1,
            dados["volatility"].iloc[i] if not pd.isna(dados["volatility"].iloc[i]) else 0
        ]
        features.append(feature_vector)
    scaler = StandardScaler()
    features_scaled = scaler.fit_transform(features)
    return torch.tensor(features_scaled, dtype=torch.float32), scaler

def create_sequences(data: torch.Tensor, seq_length: int, dados_originais: pd.DataFrame) -> tuple[torch.Tensor, torch.Tensor]:
    xs, ys = [], []
    for i in range(len(data) - seq_length):
        xs.append(data[i : i + seq_length])
        if dados_originais["close"].iloc[i + seq_length] > dados_originais["close"].iloc[i + seq_length - 1]:
            ys.append(2)
        elif dados_originais["close"].iloc[i + seq_length] < dados_originais["close"].iloc[i + seq_length - 1]:
            ys.append(0)
        else:
            ys.append(1)
    return torch.tensor(np.array(xs), dtype=torch.float32), torch.tensor(ys, dtype=torch.int64)

# Modelo
class ModeloMercado(nn.Module):
    def __init__(self, input_size: int, hidden_size: int, output_size: int, lstm_layers: int, dropout_prob: float):
        super(ModeloMercado, self).__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers=lstm_layers, batch_first=True, dropout=dropout_prob)
        self.fc = nn.Linear(hidden_size, output_size)
        self.softmax = nn.Softmax(dim=1)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        lstm_out, _ = self.lstm(x)
        out = self.fc(lstm_out[:, -1, :])
        return self.softmax(out)

# Treinamento
def treinar_modelo(modelo: nn.Module, X_train: torch.Tensor, y_train: torch.Tensor, X_val: torch.Tensor, y_val: torch.Tensor, config: dict) -> tuple[nn.Module, float]:
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    logger.info(f"Usando dispositivo: {device}")
    modelo = modelo.to(device)
    X_train, y_train = X_train.to(device), y_train.to(device)
    X_val, y_val = X_val.to(device), y_val.to(device)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(modelo.parameters(), lr=config["training"]["learning_rate"])
    dataset = TensorDataset(X_train, y_train)
    dataloader = DataLoader(dataset, batch_size=config["training"]["batch_size"], shuffle=True)
    best_val_loss = float("inf")
    patience = config["training"]["patience"]
    patience_counter = 0
    for epoch in range(config["training"]["epochs"]):
        modelo.train()
        train_loss = 0
        for batch_X, batch_y in dataloader:
            batch_X, batch_y = batch_X.to(device), batch_y.to(device)
            optimizer.zero_grad()
            output = modelo(batch_X)
            loss = criterion(output, batch_y)
            loss.backward()
            optimizer.step()
            train_loss += loss.item()
        modelo.eval()
        with torch.no_grad():
            val_output = modelo(X_val)
            val_loss = criterion(val_output, y_val).item()
            val_preds = torch.argmax(val_output, dim=1)
            val_acc = accuracy_score(y_val.cpu().numpy(), val_preds.cpu().numpy())
        train_loss /= len(dataloader)
        logger.info(f"Epoch {epoch}, Train Loss: {train_loss:.4f}, Val Acc: {val_acc:.4f}")
        if val_loss < best_val_loss:
            best_val_loss = val_loss
            patience_counter = 0
            torch.save(modelo.state_dict(), "modelo.pt")
        else:
            patience_counter += 1
            if patience_counter >= patience:
                break
    modelo.load_state_dict(torch.load("modelo.pt"))
    modelo = modelo.to("cpu")
    return modelo, val_acc

def prever(modelo: nn.Module, dados_entrada: torch.Tensor) -> torch.Tensor:
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    modelo = modelo.to(device)
    dados_entrada = dados_entrada.to(device)
    modelo.eval()
    with torch.no_grad():
        saida = modelo(dados_entrada)
        previsao = torch.argmax(saida, dim=1)
    return previsao.cpu()

# FastAPI App
app = FastAPI()

class PredictionRequest(BaseModel):
    ativo: str

@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = USERS_DB.get(form_data.username)
    if not user or user["password"] != form_data.password:
        raise HTTPException(status_code=401, detail="Credenciais inválidas")
    access_token = create_access_token(data={"sub": form_data.username})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/", response_class=HTMLResponse)
async def get_index():
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Previsão de Mercado</title>
        <style>
            body { font-family: Arial; margin: 20px; }
            .container { max-width: 500px; margin: auto; }
            input, select, button { padding: 10px; margin: 5px; width: 100%; }
            #login, #prediction { display: none; }
            #result, #chart { margin-top: 20px; border: 1px solid #ccc; padding: 10px; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Previsão de Mercado</h1>
            <div id="login">
                <h2>Login</h2>
                <input type="text" id="username" placeholder="Usuário"><br>
                <input type="password" id="password" placeholder="Senha"><br>
                <button onclick="doLogin()">Entrar</button>
            </div>
            <div id="prediction">
                <h2>Previsão</h2>
                <select id="ativo">
                    <option value="USD/BRL Futuro">USD/BRL Futuro</option>
                    <option value="S&P 500 Futuro">S&P 500 Futuro</option>
                </select><br>
                <button onclick="runPrediction()">Executar Previsão</button>
            </div>
            <div id="result">Aguardando...</div>
            <div id="chart"></div>
        </div>
        <script>
            let token = null;
            function doLogin() {
                const username = document.getElementById("username").value;
                const password = document.getElementById("password").value;
                fetch("/token", {
                    method: "POST",
                    headers: { "Content-Type": "application/x-www-form-urlencoded" },
                    body: `username=${username}&password=${password}`
                }).then(response => response.json())
                .then(data => {
                    if (data.access_token) {
                        token = data.access_token;
                        document.getElementById("login").style.display = "none";
                        document.getElementById("prediction").style.display = "block";
                    } else {
                        alert("Erro: " + data.detail);
                    }
                }).catch(error => alert("Erro: " + error));
            }
            async function runPrediction() {
                const ativo = document.getElementById("ativo").value;
                const resultDiv = document.getElementById("result");
                const chartDiv = document.getElementById("chart");
                resultDiv.innerHTML = "Processando...";
                chartDiv.innerHTML = "";
                try {
                    const response = await fetch("/predict", {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${token}` },
                        body: JSON.stringify({ ativo: ativo })
                    });
                    const data = await response.json();
                    if (response.ok) {
                        resultDiv.innerHTML = `
                            <strong>Resultados para ${ativo}:</strong><br>
                            Acurácia: ${data.val_acc.toFixed(4)}
                        `;
                        chartDiv.innerHTML = data.chart_html;
                    } else {
                        resultDiv.innerHTML = `Erro: ${data.detail}`;
                    }
                } catch (error) {
                    resultDiv.innerHTML = `Erro: ${error}`;
                }
            }
        </script>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)

@app.post("/predict")
async def predict(request: PredictionRequest, user: str = Depends(get_current_user)):
    try:
        logger.info(f"Previsão para {request.ativo} por {user}")
        df = get_dados_ativo(request.ativo, CONFIG["data"]["api"], CONFIG["data"]["use_fallback"])
        features, scaler = processar_dados(df, CONFIG["data"]["lookback_period"])
        X, y = create_sequences(features, CONFIG["data"]["sequence_length"], df)
        train_size = int(0.7 * len(X))
        val_size = int(0.15 * len(X))
        X_train, X_val, X_test = X[:train_size], X[train_size:train_size + val_size], X[train_size + val_size:]
        y_train, y_val, y_test = y[:train_size], y[train_size:train_size + val_size], y[train_size + val_size:]
        modelo = ModeloMercado(
            input_size=X.shape[2],
            hidden_size=CONFIG["model"]["hidden_size"],
            output_size=CONFIG["model"]["output_size"],
            lstm_layers=CONFIG["model"]["lstm_layers"],
            dropout_prob=CONFIG["model"]["dropout_prob"]
        )
        modelo_treinado, val_acc = treinar_modelo(modelo, X_train, y_train, X_val, y_val, CONFIG)
        chart_html = gerar_grafico_precos(df, request.ativo)
        logger.info(f"Previsão concluída: Acurácia={val_acc:.4f}")
        return {"val_acc": val_acc, "chart_html": chart_html}
    except Exception as e:
        logger.error(f"Erro: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
